<!DOCTYPE html>
<html>
<head>
  <title>Routing Algorithm Simulator</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .road-line {
      z-index: 5;
    }
    .path-line {
      z-index: 15;
    }
    .start-icon, .end-icon {
      z-index: 100;
    }
    .legend {
      padding: 10px;
      background: white;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      line-height: 1.5;
    }
    .legend i {
      width: 18px;
      height: 18px;
      float: left;
      margin-right: 8px;
      opacity: 0.7;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #blockage-controls {
      position: absolute;
      top: 100px;
      right: 20px;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
    }
    #blocking-toggle:checked + label {
      background-color: #4ade80; /* Green when active */
    }
    #blocking-toggle:not(:checked) + label {
      background-color: #f87171; /* Red when inactive */
    }
    #blocking-toggle:not(:checked) + label span {
      transform: translateX(0);
    }
    .road-line.blocked {
      stroke-dasharray: 10, 10;
    }
  </style>
</head>
<body class="flex flex-col h-screen p-5 m-0 font-sans">
  <h1 class="text-2xl font-bold text-gray-800 mb-4">Routing Algorithm Simulator</h1>

  <div class="input-container mb-5 flex-shrink-0 flex items-center gap-4">
    <!-- Start Node -->
    <div class="flex items-center bg-white rounded-lg border border-gray-300 px-3 py-2">
      <label for="start_node" class="mr-2 text-gray-700 whitespace-nowrap">Start Node:</label>
      <input type="text" id="start_node" placeholder="(40.817, -73.925)" 
            class="px-2 py-1 w-40 focus:outline-none" />
    </div>
    
    <!-- End Node -->
    <div class="flex items-center bg-white rounded-lg border border-gray-300 px-3 py-2">
      <label for="end_node" class="mr-2 text-gray-700 whitespace-nowrap">End Node:</label>
      <input type="text" id="end_node" placeholder="(40.828, -73.920)" 
            class="px-2 py-1 w-40 focus:outline-none" />
    </div>

    <!-- Blocking controls -->
    <div class="flex items-center bg-gray-100 rounded-lg px-3 py-2 border border-gray-300">
      <span class="mr-2 text-sm text-gray-700 whitespace-nowrap">Block Mode:</span>
      <div class="relative inline-block w-10 mr-2 align-middle select-none">
        <input type="checkbox" id="blocking-toggle" class="sr-only" checked>
        <label for="blocking-toggle" class="block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer transition-colors duration-200 ease-in-out">
          <span class="block h-6 w-6 rounded-full bg-white shadow-md transform transition-transform duration-300 ease-in-out translate-x-4"></span>
        </label>
      </div>
      <span class="text-sm text-gray-600 whitespace-nowrap">
        (<span id="blocked-count">0</span>/10)
      </span>
    </div>
    
    <!-- Run Simulation Button -->
    <button onclick="runSimulation()" 
            class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 whitespace-nowrap">
      Run Simulation
    </button>

    <!-- Reset Button -->
    <button onclick="resetAll()" 
            class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 whitespace-nowrap">
      Reset
    </button>
  </div>
  <div class="flex flex-1 gap-4" style="min-height: 0;">
    <div id="map-container" class="flex-1 border border-gray-300 rounded-lg overflow-hidden relative">
      <div id="map" class="w-full h-full"></div>
    </div>

    <div id="results-container" class="w-1/3 border border-gray-300 rounded-lg bg-gray-50 shadow-sm flex flex-col">
      <h3 class="text-lg font-semibold text-gray-800 p-4 border-b border-gray-300">Routing Results</h3>
      <div id="results" class="flex-1 overflow-auto p-4">
        <!-- Results will be inserted here -->
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script>
  let map;
  let startMarker, endMarker;
  let pathLayers = {};
  let roadLayers = [];
  let allRoads = [];
  let blockedEdges = new Set();
  const MAX_BLOCKED = 10;
  let isBlockingMode = true;
  
  // Updated color scheme
  const algorithmColors = {
    'Dijkstra': '#2563eb',     // Blue-600
    'A*': '#9333ea',          // Purple-600
    'Greedy BFS': '#16a34a',   // Green-600
    'Ant Colony': '#92400e'    // Brown-600
  };

  // Initialize map
  function initMap() {
    map = L.map('map').setView([40.817387, -73.925413], 15);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Add legend
    const legend = L.control({position: 'bottomright'});
    legend.onAdd = function() {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML = '<h4 class="font-bold mb-2">Map Legend</h4>';
      div.innerHTML += '<i style="background:#888888"></i>Normal Road<br>';
      div.innerHTML += '<i style="background:#FF0000"></i>Blocked Road<br>';
      for (const algo in algorithmColors) {
        div.innerHTML += 
          `<i style="background:${algorithmColors[algo]}"></i>${algo} Path<br>`;
      }
      return div;
    };
    legend.addTo(map);

    // Setup blocking mode toggle
    document.getElementById('blocking-toggle').addEventListener('change', function(e) {
      isBlockingMode = e.target.checked;
    });

    loadRoadData();
  }

  // Strict coordinate validation to match CSV format
  function validateCoordinate(coordStr) {
    const regex = /^\(-?\d+\.\d+,\s*-?\d+\.\d+\)$/;
    if (!regex.test(coordStr)) {
      return null;
    }
    // Check if coordinate exists in road data
    return allRoads.some(road => 
      road.start_node === coordStr || road.end_node === coordStr
    ) ? coordStr : null;
  }

  // Parse and validate coordinate input
  function parseCoordinateInput(coordStr) {
    // Remove any extra whitespace
    coordStr = coordStr.trim();
    
    // Try to validate as-is first
    let validated = validateCoordinate(coordStr);
    if (validated) return validated;
    
    // Try to parse if user entered raw numbers
    const numbers = coordStr.match(/-?\d+\.\d+/g);
    if (numbers && numbers.length === 2) {
      const formatted = `(${numbers[0]}, ${numbers[1]})`;
      validated = validateCoordinate(formatted);
      if (validated) return validated;
    }
    
    return null;
  }

  // Convert path to LatLng array
  function pathToLatLngs(path) {
    return path.map(node => {
      const coords = node.match(/-?\d+\.\d+/g);
      return coords ? L.latLng(parseFloat(coords[0]), parseFloat(coords[1])) : null;
    }).filter(coord => coord !== null);
  }

  // Clear previous paths from map
  function clearPaths() {
    for (const algo in pathLayers) {
      map.removeLayer(pathLayers[algo]);
    }
    pathLayers = {};
    if (startMarker) map.removeLayer(startMarker);
    if (endMarker) map.removeLayer(endMarker);
  }

  // Clear road data from map
  function clearRoads() {
    roadLayers.forEach(layer => map.removeLayer(layer.layer));
    roadLayers = [];
  }

  // Load road data from server
  async function loadRoadData() {
    try {
      const response = await fetch('/get_road_data');
      allRoads = await response.json();
      plotRoads(allRoads);
    } catch (error) {
      console.error('Error loading road data:', error);
    }
  }

  // Plot all roads on the map
  function plotRoads(roads) {
      clearRoads();
      
      roads.forEach(road => {
          const startCoords = road.start_node.match(/-?\d+\.\d+/g);
          const endCoords = road.end_node.match(/-?\d+\.\d+/g);
          
          if (startCoords && endCoords) {
              // Check both directions for blocked status
              const forwardKey = `${road.start_node.trim()},${road.end_node.trim()}`;
              const reverseKey = `${road.end_node.trim()},${road.start_node.trim()}`;
              
              const isBlocked = Array.from(blockedEdges).some(storedEdge => {
                  try {
                      const parsedEdge = JSON.parse(storedEdge);
                      return (parsedEdge.start_node === road.start_node.trim() && 
                              parsedEdge.end_node === road.end_node.trim()) ||
                            (parsedEdge.start_node === road.end_node.trim() && 
                              parsedEdge.end_node === road.start_node.trim());
                  } catch (e) {
                      return false;
                  }
              });
              const line = L.polyline([
                  [parseFloat(startCoords[0]), parseFloat(startCoords[1])],
                  [parseFloat(endCoords[0]), parseFloat(endCoords[1])]
              ], {
                  color: isBlocked ? '#FF0000' : '#888888',
                  weight: isBlocked ? 4 : 2,
                  opacity: 0.7,
                  className: 'road-line' + (isBlocked ? ' blocked' : '')
              }).addTo(map);

              // Make roads clickable for blocking/unblocking
              line.on('click', function(e) {
                  handleRoadBlocking({
                      start_node: road.start_node,
                      end_node: road.end_node,
                      layer: line
                  });
              });
              
              roadLayers.push({
                  start: road.start_node,
                  end: road.end_node,
                  layer: line,
                  isBlocked: isBlocked
              });
          }
      });
      updateBlockedCount();
  }

  // Function to handle road blocking/unblocking
  function handleRoadBlocking(road) {
      if (!isBlockingMode) return;

      // Create a proper edge object
      const edge = {
          start_node: road.start_node.trim(),
          end_node: road.end_node.trim()
      };
      
      // Stringify for consistent comparison
      const edgeKey = JSON.stringify(edge);
      const reverseEdgeKey = JSON.stringify({
          start_node: edge.end_node,
          end_node: edge.start_node
      });

      // Check if already blocked (either direction)
      let isAlreadyBlocked = false;
      const edgesToRemove = [];
      
      blockedEdges.forEach(storedEdge => {
          const parsedEdge = JSON.parse(storedEdge);
          if ((parsedEdge.start_node === edge.start_node && 
              parsedEdge.end_node === edge.end_node) ||
              (parsedEdge.start_node === edge.end_node && 
              parsedEdge.end_node === edge.start_node)) {
              isAlreadyBlocked = true;
              edgesToRemove.push(storedEdge);
          }
      });

      if (isAlreadyBlocked) {
          // Unblock all matching edges
          edgesToRemove.forEach(e => blockedEdges.delete(e));
      } else {
          if (blockedEdges.size >= MAX_BLOCKED) {
              alert(`Maximum ${MAX_BLOCKED} blocked roads allowed`);
              return;
          }
          // Block this direction
          blockedEdges.add(edgeKey);
      }

      updateBlockedCount();
      plotRoads(allRoads);
  }

  function updateBlockedCount() {
    document.getElementById('blocked-count').textContent = blockedEdges.size;
  }

  async function runSimulation() {
    const startNodeInput = document.getElementById("start_node").value.trim();
    const endNodeInput = document.getElementById("end_node").value.trim();
    const resultsDiv = document.getElementById("results");

    // Validate coordinates
    const startNode = parseCoordinateInput(startNodeInput);
    const endNode = parseCoordinateInput(endNodeInput);
    
    if (!startNode || !endNode) {
      resultsDiv.innerHTML = `
        <p class="text-red-600 font-semibold">
          Please provide valid start and end coordinates that match road network nodes.
          <br>Example: (40.817387, -73.925413)
        </p>`;
      return;
    }

    // Prepare blocked edges in CORRECT format
    const blockedEdgesArray = Array.from(blockedEdges).map(edge => {
        try {
            return JSON.parse(edge); // Parse the stored JSON string
        } catch (e) {
            console.error("Error parsing edge:", edge);
            return null;
        }
    }).filter(edge => edge !== null);


    // Prepare request data in exact format
    const requestData = {
      start_node: startNode,
      end_node: endNode,
      blocked_edges: blockedEdgesArray
    };

      // Debug: Log the formatted blocked edges
    console.log("Formatted blocked_edges:", JSON.stringify(blockedEdgesArray, null, 2));

    console.log("Sending to server:", JSON.stringify(requestData, null, 2));

    resultsDiv.innerHTML = `
      <div class="h-full flex items-center justify-center text-gray-500">
        <div class="animate-spin rounded-full h-5 w-5 border-t-2 border-b-2 border-blue-500 mr-2"></div>
        <span>Calculating routes...</span>
      </div>`;
    clearPaths();

    try {
      const response = await fetch("/run_simulation", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(requestData)
      });

      if (!response.ok) {
        throw new Error(`Server returned ${response.status}`);
      }

      const data = await response.json();
      if (!data.results || !Array.isArray(data.results)) {
        throw new Error("Invalid server response format");
      }

      // Add markers for start and end points
      const startCoords = startNode.match(/-?\d+\.\d+/g);
      const endCoords = endNode.match(/-?\d+\.\d+/g);
      
      if (startCoords) {
        startMarker = L.marker([parseFloat(startCoords[0]), parseFloat(startCoords[1])], {
          icon: L.divIcon({className: 'start-icon', html: '🟢', iconSize: [20, 20]})
        }).addTo(map).bindPopup("Start Point");
      }
      
      if (endCoords) {
        endMarker = L.marker([parseFloat(endCoords[0]), parseFloat(endCoords[1])], {
          icon: L.divIcon({className: 'end-icon', html: '🔴', iconSize: [20, 20]})
        }).addTo(map).bindPopup("End Point");
      }

      // Fit bounds to include both points
      if (startCoords && endCoords) {
        map.fitBounds([
          [parseFloat(startCoords[0]), parseFloat(startCoords[1])],
          [parseFloat(endCoords[0]), parseFloat(endCoords[1])]
        ], {padding: [50, 50]});
      }

      // Update results table
      let table = `
        <table class="w-full text-sm mb-4">
          <thead>
            <tr class="bg-blue-800 text-white">
              <th class="px-3 py-2 text-left font-semibold">Algorithm</th>
              <th class="px-3 py-2 text-left font-semibold">Cost</th>
              <th class="px-3 py-2 text-left font-semibold">Time (s)</th>
              <th class="px-3 py-2 text-center font-semibold">Nodes</th>
              <th class="px-3 py-2 text-left font-semibold">Status</th>
            </tr>
          </thead>
          <tbody>`;

      // Process each algorithm's result
      for (const result of data.results) {
        const statusIcon = result.path_found ? 
          '<span class="mr-1">✅</span>' : 
          '<span class="mr-1">❌</span>';
        const statusText = result.path_found ? 'Found' : 'Not Found';
        const statusClass = result.path_found ? 'text-green-600 font-semibold' : 'text-red-600 font-semibold';
        
        table += `
          <tr class="hover:bg-blue-50 even:bg-gray-100">
            <td class="px-3 py-2 font-semibold text-gray-800">${result.algorithm}</td>
            <td class="px-3 py-2 font-mono font-semibold">${result.cost !== -1 ? result.cost.toFixed(2) : 'N/A'}</td>
            <td class="px-3 py-2 font-mono text-gray-500">${result.execution_time !== -1 ? result.execution_time.toFixed(4) : 'N/A'}</td>
            <td class="px-3 py-2 text-center">${result.path_length}</td>
            <td class="px-3 py-2 ${statusClass}">
              ${statusIcon}${statusText}
            </td>
          </tr>`;

        // Add path to map if found
        if (result.path_found && result.path) {
          const latLngs = pathToLatLngs(result.path);
          if (latLngs.length > 1) {
            const pathLayer = L.polyline(latLngs, {
              color: algorithmColors[result.algorithm],
              weight: 4,
              opacity: 0.7,
              dashArray: result.algorithm === 'Ant Colony' ? '5, 5' : null,
              className: 'path-line'
            }).addTo(map).bindPopup(`${result.algorithm} Path`);
            
            pathLayers[result.algorithm] = pathLayer;
          }
        }
      }

      table += "</tbody></table>";

      // Add blocked roads list
      let blockedRoadsList = '<div class="w-full text-sm"><h4 class="font-semibold text-gray-800 mb-2">Blocked Roads:</h4>';
      if (blockedEdges.size > 0) {
        blockedEdgesArray.forEach(road => {
          blockedRoadsList += `<div class="text-sm text-red-600 py-1">${road.start_node} → ${road.end_node}</div>`;
        });
      } else {
        blockedRoadsList += '<div class="text-sm text-gray-500 py-1">No roads currently blocked</div>';
      }
      blockedRoadsList += '</div>';

      resultsDiv.innerHTML = table + blockedRoadsList;

    } catch (error) {
      resultsDiv.innerHTML = `
        <p class="text-red-600 font-semibold">
          Error: ${error.message}
          <br>Please check your inputs and try again.
        </p>`;
      console.error("Simulation error:", error);
    }
  }

  function resetAll() {
    // Clear blocked edges
    blockedEdges.clear();
    updateBlockedCount();
    
    // Reset road styles
    roadLayers.forEach(road => {
      road.layer.setStyle({
        color: '#888888',
        weight: 2,
        className: 'road-line'
      });
    });
    
    // Clear paths and markers
    clearPaths();
    
    // Clear results display
    document.getElementById('results').innerHTML = '';
    
    // Reset blocking mode toggle
    document.getElementById('blocking-toggle').checked = true;
    isBlockingMode = true;
  }

  // Initialize map when page loads
  window.onload = initMap;
</script>
</body>
</html>